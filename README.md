Certainly! Here's a combined table for all techniques with the added columns:

### Techniques Table

| **Category**          | **#** | **Technique**                     | **Problem 1**                                                | **Problem 2**                                               | **Hint**                                                                                      | **Time Complexity** | **Expected Time to Solve** | **Is Completed** | **Date**       |
|-----------------------|-------|-----------------------------------|--------------------------------------------------------------|------------------------------------------------------------|------------------------------------------------------------------------------------------------|---------------------|----------------------------|------------------|----------------|
| **Array Techniques**  | 1     | Two Pointer Technique             | Find the pair in a sorted array that sums to a given value   | Remove duplicates from a sorted array                       | Use two pointers starting from the beginning and end of the array, moving towards each other.  | O(n)                | 30 mins                    |                  | 2024-07-17     |
|                       | 2     | Sliding Window Technique          | Maximum sum of a subarray of size k                          | Longest substring without repeating characters              | Slide a window of fixed size across the array/string, updating the result as you go.           | O(n)                | 45 mins                    |                  | 2024-07-18     |
|                       | 3     | Prefix Sum Technique              | Find the equilibrium index of an array                       | Range sum query (immutable)                                 | Precompute prefix sums and use them to answer range queries efficiently.                       | O(n)                | 30 mins                    |                  | 2024-07-19     |
|                       | 4     | Binary Search Technique           | Find the square root of a number                             | Search in a rotated sorted array                            | Use the divide and conquer approach to narrow down the search range.                           | O(log n)            | 45 mins                    |                  | 2024-07-20     |
|                       | 5     | Two Sum Technique                 | Find two numbers that add up to a specific target            | Two sum problem in a sorted array                           | Use a hash map to store the differences or two pointers in a sorted array.                     | O(n)                | 30 mins                    |                  | 2024-07-22     |
|                       | 6     | Merge Intervals Technique         | Merge overlapping intervals                                  | Insert an interval into a sorted list of intervals          | Sort intervals and then merge or insert while checking overlaps.                               | O(n log n)          | 60 mins                    |                  | 2024-07-23     |
|                       | 7     | Kadane's Algorithm                | Maximum subarray sum                                         | Maximum sum of two non-overlapping subarrays                | Use dynamic programming to find the maximum sum subarray or non-overlapping subarrays.         | O(n)                | 45 mins                    |                  | 2024-07-24     |
|                       | 8     | Dutch National Flag Algorithm     | Sort an array of 0s, 1s, and 2s                              | Segregate even and odd numbers                              | Use three pointers to partition the array into groups of 0s, 1s, and 2s.                       | O(n)                | 30 mins                    |                  | 2024-07-25     |
|                       | 9     | Sweep Line Technique              | Find the number of intervals overlapping at a given point    | Meeting rooms (find the minimum number of meeting rooms required) | Use events and a priority queue to track intervals and their overlap at each point.             | O(n log n)          | 60 mins                    |                  | 2024-07-26     |
|                       | 10    | Maximal Subarray Sum             | Maximum sum of a subarray                                    | Maximum sum of a circular subarray                          | Use Kadane's algorithm for the maximum subarray sum and consider circular subarrays separately.| O(n)                | 45 mins                    |                  | 2024-07-27     |
| **String Techniques** | 11    | String Manipulation               | Reverse words in a string                                    | Check if two strings are anagrams                           | Reverse words using two pointers and check anagrams using character frequency maps.            | O(n)                | 30 mins                    |                  | 2024-07-29     |
|                       | 12    | Sliding Window for Strings        | Minimum window substring                                     | Longest substring with at most two distinct characters      | Slide a window to find the minimum substring or longest substring with two distinct characters.| O(n)                | 45 mins                    |                  | 2024-07-30     |
|                       | 13    | Two Pointers for Strings          | Valid palindrome                                             | Compare backspace strings                                   | Use two pointers to check characters or ignore backspaces while comparing strings.             | O(n)                | 30 mins                    |                  | 2024-07-31     |
|                       | 14    | Hashing for Strings              | Group anagrams                                               | Find the first non-repeating character                      | Use hash maps for anagram grouping or tracking character frequencies.                          | O(n)                | 45 mins                    |                  | 2024-08-01     |
|                       | 15    | String Matching Algorithms       | Knuth-Morris-Pratt (KMP) algorithm                           | Rabin-Karp algorithm                                        | Use prefix function for KMP or hash function for Rabin-Karp to find pattern matches efficiently.| O(n + m)            | 60 mins                    |                  | 2024-08-02     |
|                       | 16    | Run-Length Encoding              | Implement run-length encoding                                | Decode a run-length encoded string                          | Encode consecutive characters or decode encoded strings using specified algorithms.           | O(n)                | 45 mins                    |                  | 2024-08-03     |
|                       | 17    | Trie Data Structure              | Implement a trie (insert, search, startsWith)                | Word search II (using a trie)                               | Implement trie operations for efficient prefix-based operations or word search solutions.     | O(n)                | 60 mins                    |                  | 2024-08-04     |
|                       | 18    | Regular Expression Matching      | Implement regular expression matching                       | Wildcard matching                                           | Implement parsing and matching using regex patterns or wildcard characters.                    | O(m * n)            | 60 mins                    |                  | 2024-08-05     |
|                       | 19    | Manacher's Algorithm             | Longest palindromic substring                               | Count all palindromic substrings in a string                | Use Manacher's algorithm to find longest palindromic substrings or count all palindromes.     | O(n)                | 45 mins                    |                  | 2024-08-06     |
|                       | 20    | Anagram Techniques               | Find all anagrams in a string                                | Check if two strings are anagrams of each other             | Use character frequency maps or sorted strings to determine anagram relationships.             | O(n)                | 30 mins                    |                  | 2024-08-07     |
| **Linked List Techniques** | 21 | Runner Technique                  | Remove the N-th node from the end of the list               | Find the middle of a linked list                            | Use two pointers with different speeds to find nodes or partition lists efficiently.          | O(n)                | 45 mins                    |                  | 2024-08-08     |
|                       | 22    | Floyd's Cycle Detection Algorithm | Detect a cycle in a linked list                              | Find the starting node of the cycle                          | Use two pointers, one moving faster than the other, to detect cycles or find cycle origins.   | O(n)                | 30 mins                    |                  | 2024-08-09     |
|                       | 23    | Reverse Linked List              | Reverse a singly linked list                                 | Reverse a linked list in groups of k                        | Use iterative or recursive methods to reverse linked lists or reverse in specified groups.    | O(n)                | 45 mins                    |                  | 2024-08-10     |
|                       | 24    | Merge Two Sorted Lists           | Merge two sorted linked lists                                | Merge k sorted linked lists                                 | Use iterative merging or priority queues for efficient merging of sorted lists.                | O(n log k)          | 60 mins                    |                  | 2024-08-11     |
|                       | 25    | Delete Node in a Linked List     | Delete a node given only access to that node                 | Delete the middle node of a linked list                     | Copy data from the next node and remove it or adjust pointers to delete specific nodes.        | O(1)                | 30 mins                    |                  | 2024-08-12     |
|                       | 26    | Detect Cycle in a Linked List    | Detect a cycle in a linked list                             | Find the length of the cycle                                | Use Floyd's cycle detection algorithm to detect cycles or determine cycle lengths.            | O(n)                | 45 mins                    |                  | 2024-08-13     |
|                       | 27    | Find Intersection Point of Two Linked Lists | Find the intersection point of two linked lists   | Determine if two linked lists intersect                     | Calculate lengths and adjust starting points to find intersections or use set intersections.   | O(n)                | 30 mins                    |                  | 2024-08-14     |
|                       | 28    | Remove Nth Node from End of List | Remove the N-th node from the end of the list               | Find the N-th node from the end                             | Use two pointers or count nodes to locate and remove specified nodes

 from the end.            | O(n)                | 45 mins                    |                  | 2024-08-15     |
| **Stack and Queue Techniques** | 29 | Implement Stack using Queues     | Implement a stack using queues                              | Implement a queue using stacks                              | Use two queues or two stacks to simulate stack or queue operations efficiently.                | O(1)                | 30 mins                    |                  | 2024-08-16     |
|                       | 30    | Implement Queue using Stacks     | Implement a queue using stacks                              | Implement a circular queue                                  | Use two stacks or arrays to perform queue or circular queue operations efficiently.           | O(1)                | 45 mins                    |                  | 2024-08-17     |
|                       | 31    | Design Min Stack                 | Design a stack that supports push, pop, top, and retrieving the minimum element | Implement a circular queue                        | Use a secondary stack to track minimum elements or adjust pointers to implement circular queues. | O(1)                | 30 mins                    |                  | 2024-08-18     |
|                       | 32    | Sliding Window Maximum           | Find the maximum values in a sliding window                  | Design a deque                                             | Use a deque to track maximums or minimums efficiently within sliding windows.                   | O(n)                | 45 mins                    |                  | 2024-08-19     |
|                       | 33    | Implement Double-ended Queue    | Design a deque with basic operations                        | Design a deque supporting minimum or maximum queries        | Use arrays or linked lists with front and rear pointers to support deque operations.           | O(1)                | 30 mins                    |                  | 2024-08-20     |
| **Tree Techniques**   | 34    | Binary Search Tree (BST)         | Implement BST operations (insert, delete, search)            | Validate BST properties                                     | Use recursion or iterative methods to manage BST operations or validate BST structures.       | O(log n)            | 60 mins                    |                  | 2024-08-21     |
|                       | 35    | Depth-First Search (DFS)         | Traverse a tree in preorder, inorder, postorder              | Find all nodes at a given distance K from a target node     | Use recursion or stacks to traverse trees in specified orders or find nodes at given distances.| O(n)                | 45 mins                    |                  | 2024-08-22     |
|                       | 36    | Breadth-First Search (BFS)       | Level order traversal of a tree                             | Minimum depth of a binary tree                              | Use queues to traverse trees level-wise or find minimum depths efficiently.                    | O(n)                | 30 mins                    |                  | 2024-08-23     |
|                       | 37    | Binary Tree Properties           | Symmetric tree                                                | Check if two binary trees are identical                    | Use recursion or iterative methods to check tree properties or compare binary trees.           | O(n)                | 45 mins                    |                  | 2024-08-24     |
|                       | 38    | Binary Tree Diameter            | Find the diameter of a binary tree                           | Path sum equals target                                      | Use recursion to find maximum path lengths or validate path sums in binary trees.              | O(n)                | 60 mins                    |                  | 2024-08-25     |
|                       | 39    | Validate Binary Search Tree     | Check if a binary tree is a valid BST                       | Path with given sequence                                    | Use recursion or iterative methods to validate BST properties or paths in binary trees.       | O(n)                | 45 mins                    |                  | 2024-08-26     |
|                       | 40    | Binary Tree Zigzag Level Order   | Zigzag level order traversal of a binary tree               | Maximum width of a binary tree                              | Use queues or stacks to traverse trees in zigzag orders or find maximum widths in binary trees.| O(n)                | 30 mins                    |                  | 2024-08-27     |
| **Graph Techniques**  | 41    | Graph Representation            | Implement graph representations (adjacency list/matrix)      | Detect cycle in a directed graph                            | Use arrays or hash maps to represent graphs or detect cycles efficiently in directed graphs.  | O(V + E)            | 45 mins                    |                  | 2024-08-28     |
|                       | 42    | Depth-First Search (DFS)         | Implement DFS traversal of a graph                          | Find all paths from source to destination in a directed graph | Use recursion or stacks to traverse graphs depth-wise or find specific paths in graphs.        | O(V + E)            | 30 mins                    |                  | 2024-08-29     |
|                       | 43    | Breadth-First Search (BFS)       | Implement BFS traversal of a graph                          | Shortest path in an unweighted graph                        | Use queues to traverse graphs breadth-wise or find shortest paths in unweighted graphs.       | O(V + E)            | 45 mins                    |                  | 2024-08-30     |
|                       | 44    | Topological Sorting              | Implement topological sorting of a DAG                      | Alien dictionary                                            | Use DFS or Kahn's algorithm to perform topological sorting or resolve dependencies in DAGs.   | O(V + E)            | 60 mins                    |                  | 2024-08-31     |
|                       | 45    | Minimum Spanning Tree (MST)      | Implement Prim's or Kruskal's algorithm                     | Network delay time                                          | Use heaps or disjoint sets to find MSTs or calculate network delays efficiently.             | O(E log V)          | 45 mins                    |                  | 2024-09-01     |
|                       | 46    | Shortest Path Algorithms         | Dijkstra's algorithm                                          | Bellman-Ford algorithm                                      | Use heaps or arrays to find shortest paths using Dijkstra's or handle negative weights in Bellman-Ford. | O((V + E) log V)    | 60 mins                    |                  | 2024-09-02     |
|                       | 47    | Strongly Connected Components    | Kosaraju's or Tarjan's algorithm                            | Bridges and articulation points                             | Use DFS-based approaches to find SCCs or identify critical components in graphs.             | O(V + E)            | 45 mins                    |                  | 2024-09-03     |
| **Dynamic Programming Techniques** | 48 | Fibonacci Numbers                 | Calculate nth Fibonacci number                               | Fibonacci sequence with constraints                         | Use memoization or iterative methods to compute Fibonacci numbers or handle sequence constraints. | O(n)                | 30 mins                    |                  | 2024-09-04     |
|                       | 49    | Longest Common Subsequence       | Find the length of the longest common subsequence            | Shortest common supersequence                               | Use dynamic programming to find LCS lengths or shortest supersequences efficiently.           | O(m * n)            | 45 mins                    |                  | 2024-09-05     |
|                       | 50    | Knapsack Problem                 | 0/1 Knapsack problem                                         | Unbounded knapsack problem                                  | Use dynamic programming to solve 0/1 or unbounded knapsack problems with specified constraints.| O(n * W)            | 60 mins                    |                  | 2024-09-06     |
|                       | 51    | Coin Change Problem              | Minimum coins for a given amount                            | Number of ways to make change                               | Use dynamic programming to calculate minimum coins or count ways to make change efficiently. | O(n * amount)       | 45 mins                    |                  | 2024-09-07     |
|                       | 52    | Maximum Subarray Problem         | Maximum sum of contiguous subarray                          | Maximum product subarray                                    | Use Kadane's algorithm for maximum sum subarrays or adapt for product subarrays.               | O(n)                | 30 mins                    |                  | 2024-09-08     |
|                       | 53    | Longest Increasing Subsequence   | Find the length of the longest increasing subsequence       | Minimum deletions to make array sorted                      | Use dynamic programming with binary search to find LIS lengths or modify sequences efficiently. | O(n log n)          | 45 mins                    |                  | 2024-09-09     |
| **Sorting and Searching Techniques** | 54 | Merge Sort                        | Implement merge sort algorithm                               | Count of smaller numbers after self in an array             | Use divide and conquer with merge steps to sort arrays or count elements efficiently.         | O(n log n)          | 60 mins                    |                  | 2024-09-10     |
|                       | 55    | Quick Sort                       | Implement quick sort algorithm                               | K-th smallest element in an unsorted array                  | Use partitioning and recursion to sort arrays or find specific elements efficiently.          | O(n log n)          | 45 mins                    |                  | 2024-09-11     |
|                       | 56    | Binary Search                    | Implement binary search algorithm                            | Search in a rotated sorted array                            | Use iterative or recursive methods to perform binary searches or handle rotated arrays.      | O(log n)            | 30 mins                    |                  | 2024-09-12     |
|                       | 57    | Interpolation Search             | Implement interpolation search algorithm                     | Position of an element in an infinite sorted array          | Use position estimation to perform searches efficiently or handle infinite arrays.            | O(log log n)

        | 45 mins                    |                  | 2024-09-13     |
|                       | 58    | Exponential Search               | Implement exponential search algorithm                       | Find the first and last occurrence of a number in a sorted array | Use exponential growth to locate elements or boundaries in sorted arrays efficiently.         | O(log n)            | 30 mins                    |                  | 2024-09-14     |
|                       | 59    | Jump Search                      | Implement jump search algorithm                              | Search in a rotated sorted array                            | Use fixed or variable jumps to traverse arrays efficiently or handle rotated arrays.          | O(âˆšn)               | 45 mins                    |                  | 2024-09-15     |
|                       | 60    | Ternary Search                   | Implement ternary search algorithm                           | Minimum in a rotated sorted array                           | Use divide and conquer with three points to locate values or find specific elements.          | O(log3 n)           | 30 mins                    |                  | 2024-09-16     |
| **Greedy Techniques** | 61    | Activity Selection Problem       | Maximize the number of activities that can be performed      | Fractional knapsack problem                                 | Use greedy algorithm to select activities or maximize fractions efficiently.                  | O(n log n)          | 45 mins                    |                  | 2024-09-17     |
|                       | 62    | Interval Scheduling              | Maximize the number of non-overlapping intervals            | Minimum number of meeting rooms required                    | Use sorting and greedy selection to schedule intervals or minimize meeting room requirements.| O(n log n)          | 30 mins                    |                  | 2024-09-18     |
|                       | 63    | Huffman Coding                   | Implement Huffman coding algorithm                           | Decode a Huffman encoded string                             | Use priority queues to build Huffman trees or decode encoded strings efficiently.             | O(n log n)          | 45 mins                    |                  | 2024-09-19     |
|                       | 64    | Prim's Algorithm                 | Find the minimum spanning tree (MST) using Prim's algorithm  | Shortest path in a weighted graph using Prim's algorithm    | Use priority queues to build MSTs or find shortest paths efficiently with Prim's algorithm.  | O((V + E) log V)    | 30 mins                    |                  | 2024-09-20     |
|                       | 65    | Kruskal's Algorithm              | Find the minimum spanning tree (MST) using Kruskal's algorithm | Detect cycle in an undirected graph using Kruskal's algorithm | Use sorting and union-find data structures to build MSTs or detect cycles with Kruskal's.    | O(E log V)          | 45 mins                    |                  | 2024-09-21     |
|                       | 66    | Dijkstra's Algorithm             | Find the shortest paths from source to all vertices          | Shortest path in a weighted graph using Dijkstra's algorithm | Use priority queues to find shortest paths efficiently from a single source with Dijkstra's. | O((V + E) log V)    | 60 mins                    |                  | 2024-09-22     |
|                       | 67    | Maximum Intervals Overlap        | Find the maximum number of overlapping intervals           | Meeting rooms II (maximum number of meeting rooms required) | Use sorting and greedy techniques to find maximum overlaps or meeting room requirements.     | O(n log n)          | 45 mins                    |                  | 2024-09-23     |
|                       | 68    | Job Sequencing with Deadlines    | Maximize the profit by scheduling jobs with deadlines       | Task scheduling with deadlines                              | Use sorting and greedy selection to maximize profits or schedule tasks efficiently.           | O(n log n)          | 30 mins                    |                  | 2024-09-24     |
| **Divide and Conquer Techniques** | 69 | Binary Search                    | Implement binary search algorithm                            | Search in a rotated sorted array                            | Use divide and conquer to perform searches or handle rotated arrays efficiently.             | O(log n)            | 45 mins                    |                  | 2024-09-25     |
|                       | 70    | Merge Sort                       | Implement merge sort algorithm                               | Count of smaller numbers after self in an array             | Use divide and conquer with merge steps to sort arrays or count elements efficiently.         | O(n log n)          | 60 mins                    |                  | 2024-09-26     |
|                       | 71    | Quick Sort                       | Implement quick sort algorithm                               | K-th smallest element in an unsorted array                  | Use partitioning and recursion to sort arrays or find specific elements efficiently.          | O(n log n)          | 45 mins                    |                  | 2024-09-27     |
|                       | 72    | Strassen's Matrix Multiplication | Implement Strassen's algorithm                               | Matrix chain multiplication                                | Use recursive methods to multiply matrices efficiently or handle chains of matrix multiplications.| O(n^2.81)           | 60 mins                    |                  | 2024-09-28     |
|                       | 73    | Closest Pair of Points           | Find the smallest distance between two points in a plane    | Maximum and minimum in an array                             | Use divide and conquer or sweep line methods to find closest pairs or extremum values.       | O(n log n)          | 45 mins                    |                  | 2024-09-29     |
| **Backtracking Techniques** | 74  | N-Queens Problem                 | Place N queens on an NxN chessboard                         | Generate all valid parentheses                              | Use recursive backtracking to solve placement problems or generate valid sequences.           | O(n!)               | 30 mins                    |                  | 2024-09-30     |
|                       | 75    | Sudoku Solver                    | Solve a Sudoku puzzle                                        | Generate all permutations of a string                       | Use backtracking to solve puzzles or generate permutations efficiently.                       | O(9^(n*n))          | 45 mins                    |                  | 2024-10-01     |
|                       | 76    | Combination Sum                  | Find all combinations that sum to a target                  | Palindrome partitioning                                     | Use recursive backtracking to find combinations or partition strings into palindromes.       | O(2^n)              | 60 mins                    |                  | 2024-10-02     |
|                       | 77    | Letter Combinations of a Phone Number | Generate all possible letter combinations from a phone number | Combination generation                                     | Use recursive backtracking with mapping to generate letter combinations or combinations.    | O(3^n * 4^m)        | 45 mins                    |                  | 2024-10-03     |
|                       | 78    | Permutations                     | Generate all permutations of a collection                   | Word break II (generate all possible sentences)             | Use recursive backtracking to generate permutations or sentences from word break problems.   | O(n!)               | 30 mins                    |                  | 2024-10-04     |
|                       | 79    | Subsets                          | Generate all subsets of a set                                | Generate all valid IP addresses                            | Use recursive backtracking or iterative methods to generate subsets or IP addresses.          | O(2^n)              | 45 mins                    |                  | 2024-10-05     |
| **Bit Manipulation Techniques** | 80 | Bitwise Operations               | Implement bitwise operations                                | Single number (find the single non-repeating number)        | Use bitwise XOR, AND, OR, etc., to perform operations or find specific numbers efficiently.   | O(n)                | 30 mins                    |                  | 2024-10-06     |
|                       | 81    | Counting Bits                    | Count the number of 1 bits in binary representations        | Maximum XOR of two numbers in an array                      | Use bit manipulation techniques to count bits or find maximum XOR values efficiently.         | O(n)                | 45 mins                    |                  | 2024-10-07     |
|                       | 82    | Subset Generation                | Generate all subsets using bit manipulation                 | Find missing number (bit manipulation)                      | Use bit masks to generate subsets or solve specific problems using bit manipulations.        | O(2^n)              | 60 mins                    |                  | 2024-10-08     |
| **Mathematical Techniques** | 83 | Sieve of Eratosthenes             | Generate all prime numbers up to a given limit              | Count primes less than a non-negative number                | Use arrays and multiples to mark non-prime numbers or count primes efficiently.               | O(n log log n)      | 45 mins                    |                  | 2024-10-09     |
|                       | 84    | Modular Arithmetic               | Implement modular arithmetic operations                      | N-th Fibonacci number using matrix exponentiation           | Use modulus operations to handle large numbers or compute Fibonacci sequences efficiently.    | O(log n)            | 30 mins                    |                  | 2024-10-10     |
|                       | 85    | GCD and LCM                      | Calculate the greatest common divisor and least common multiple | Consecutive numbers sum                                    | Use Euclidean algorithm or properties of numbers to compute GCDs, LCMs, or solve specific problems.| O(log min(a, b))    | 45 mins                    |                  | 2024-10-11     |
|                       | 86    | Fast Power                       | Compute power(x, n) using fast exponentiation               | Validate IP address                                         | Use iterative or recursive methods to

 compute powers efficiently or validate IP addresses.    | O(log n)            | 60 mins                    |                  | 2024-10-12     |
|                       | 87    | Prime Factorization              | Find all prime factors of a number                          | Factor combinations (mathematical problems)                  | Use trial division or sieve methods to find prime factors or factor combinations efficiently. | O(sqrt(n))          | 45 mins                    |                  | 2024-10-13     |
| **Miscellaneous Techniques** | 88 | Rabin-Karp Algorithm              | Implement Rabin-Karp string matching algorithm              | Minimum window substring                                   | Use hash functions with rolling hashes to implement string matching or find substrings efficiently.| O(n + m)            | 30 mins                    |                  | 2024-10-14     |
|                       | 89    | Floyd-Warshall Algorithm         | Find all pair shortest paths in a weighted graph            | Transitive closure of a graph                               | Use dynamic programming to find shortest paths or transitive closures in graphs efficiently.| O(V^3)              | 45 mins                    |                  | 2024-10-15     |
|                       | 90    | Bellman-Ford Algorithm           | Find the shortest paths from a single source to all vertices in a weighted graph | Distance vector routing protocol                            | Use iterative relaxation to find shortest paths efficiently from a single source.            | O(VE)               | 60 mins                    |                  | 2024-10-16     |

